/**
 * @param {import('@/types').GrammarItem[]} rules
 * @param {string[]} nt
 * @param {string[]} t
 * @param {Map<string,Set<string>>} firstSet
 */
export function lr1Automaton(rules, nt, t, firstSet) {
	/**@type {import('@/types').LR1Automaton}*/
	let automaton = { states: [], transitions: new Map() };

	/**@type {import('@/types').LR1StateItem[]} */
	let state0 = [{ pos: 0, ruleIndex: 0, lookahead: new Set(['$']) }];

	/**@type {number[]} */
	let stateStack = [];
	closure(state0, rules, nt, firstSet);

	automaton.states.push({ index: 0, items: [...state0] });

	stateStack.push(0);
	let alphabet = [...t, ...nt].filter((x) => x !== '');
	while (stateStack.length > 0) {
		for (let symbol of alphabet) {
			/**@type {import('@/types').LR1StateItem[]} */
			let state1 = [];
			for (let prod of automaton.states[stateStack[0]].items) {
				if (
					prod.pos >= rules[prod.ruleIndex].right.length ||
					rules[prod.ruleIndex].right[prod.pos] !== symbol
				)
					continue;
				if (state1.some((x) => x.ruleIndex === prod.ruleIndex && x.pos === prod.pos + 1)) continue;
				state1.push({ ruleIndex: prod.ruleIndex, pos: prod.pos + 1, lookahead: prod.lookahead });
			}
			if (state1.length === 0) continue;
			closure(state1, rules, nt, firstSet);
			let existent = automaton.states.findIndex((x) => {
				if (x.items.length != state1.length) return false;
				let eq = true;
				for (let k = 0; k < x.items.length; k++) {
					let match = false;

					for (let m = 0; m < state1.length; m++) {
						match =
							match ||
							(x.items[k].pos === state1[m].pos &&
								x.items[k].ruleIndex === state1[m].ruleIndex &&
								x.items[k].lookahead.size === state1[m].lookahead?.size &&
								x.items[k].lookahead.values().every((x) => state1[m].lookahead.has(x)));
						if (match) break;
					}
					eq = match;
					if (!eq) break;
				}
				return eq;
			});

			if (!automaton.transitions.has(stateStack[0]))
				automaton.transitions.set(stateStack[0], new Map());

			if (existent === -1) {
				automaton.states.push({ index: automaton.states.length, items: [...state1] });
				automaton.transitions.get(stateStack[0])?.set(symbol, automaton.states.length - 1);
				stateStack.push(automaton.states.length - 1);
				continue;
			}

			automaton.transitions.get(stateStack[0])?.set(symbol, existent);
		}
		stateStack.shift();
	}
	return automaton;
}
